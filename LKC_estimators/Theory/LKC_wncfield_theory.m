function LKC = LKC_wncfield_theory( mask, Kernel, resadd, mask_lat, enlarge )
% LKC_WNCFIELD_THEORY( mask, Kernel, resadd, mask_lat, enlarge ) computes
% theoretical Lipschitz Killing curvatures for a convolution field
% derived from a seperable kernel with underlying discrete independent
% Gaussian white noise process on a lattice.
% It uses the fact that the voxels are independent and the variance and
% mean are known.
%
%--------------------------------------------------------------------------
% ARGUMENTS
% Mandatory
%  mask     a logical array of dimension T_1 x...x T_D.
%  Kernel   either an object of class SepKernel or a numeric.
%           If class SepKernel all fields must be specified.
%
%           If Kernel is numeric, the convolution field is generated by 
%           smoothing with an isotropic Gaussian kernel with FWHM = Kernel.
%           Truncation and adjust_kernel are set to be default values.
% Optional
%  resadd    integer denoting the amount of voxels padded between existing 
%            voxels to increase resolution. Default 1.
%  mask_lat  an logical. If 1 the mask is applied to the lat_data prior
%            to any other calculation. Default 0.
%            Note that if 0 the mask is only applied after convolutions
%            are performed.              
%  enlarge   an integer denoting the amount of voxels the resolution
%            increased mask is enlarged by dilation. Note that for
%            unbiased estimation resadd needs to be an odd number and
%            enlarge needs to be set to the default value currently.
%            Default ceil( resadd / 2 ).
%--------------------------------------------------------------------------
% OUTPUT
%   L  1 x D array of theoretical LKCs computed assuming independence
%      of voxels mean zero and variance 1
%--------------------------------------------------------------------------
% EXAMPLES
% %% %% D = 1 
% %% % Rectangular mask and Kernel
% % Set Kernel to be isotropic Gaussian with FHWM
% Kernel = SepKernel( 1, 3 );
% 
% % Create a mask and show it
% mask = ones( [ 30 1 ] );
% mask = pad_vals( mask, Kernel.truncation );
% plot(mask)
% title('mask')
% 
% %% Stability for increasing resadd
% % mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 1 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 1 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 1 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (seems to agree)
% lat_data = randn( [ size( mask,1 ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 1 );
% LKChat.hatL
% 
% % do not mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 0 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 0 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 0 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (seems to agree)
% lat_data = randn( [  size( mask,1 ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 0 );
% LKChat.hatL
% 
% %% % Complicated Mask and Kernel
% % Set Kernel to be isotropic Gaussian with FHWM
% Kernel = SepKernel( 1, 20 );
% 
% % Create a mask and show it
% Sig = gensig([1,2], 3, [10,20], [100,150], {[40,30], [70,120]});
% mask = logical( Sig > 0.02 );
% mask = mask(50,:)';
% plot( mask ),
% title( 'mask' )
% 
% %% Stability for increasing resadd
% % mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 1 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 1 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 1 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result
% lat_data = randn( [ size( mask,1 ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 1 );
% LKChat.hatL
% 
% % do not mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 0 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 0 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 0 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result
% lat_data = randn( [ size( mask,1 ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 0 );
% LKChat.hatL
% 
% %% %% D = 2 
% %% % Rectangular mask and Kernel
% % Set Kernel to be isotropic Gaussian with FHWM
% Kernel = SepKernel( 2, 3 );
% 
% % Create a mask and show it
% mask = ones( [ 30 30 ] );
% mask = pad_vals( mask, Kernel.truncation );
% imagesc(mask)
% 
% %% Stability for increasing resadd
% % mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 1 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 1 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 1 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (seems to agree)
% lat_data = randn( [ size( mask ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 1 );
% LKChat.hatL
% 
% % do not mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 0 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 0 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 0 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (seems to agree)
% pad_mask = pad_vals( mask, Kernel.truncation );
% lat_data = randn( [ size(pad_mask ) 200 ] );
% LKChat = LKC_conv_est( lat_data, pad_mask, Kernel, 1, 0 );
% LKChat.hatL
% 
% %% % Complicated mask and Kernel
% % Set Kernel to be isotropic Gaussian with FHWM
% Kernel = SepKernel( 2, 20 );
% 
% % Create a mask and show it
% Sig  = gensig( [1,2], 3, [10,20], [70,100], {[30,20], [50,70]} );
% mask = logical( Sig > 0.02 & Sig < 1.1 );
% imagesc(mask)
% 
% %% Stability for increasing resadd
% % mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 1 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 1 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 1 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (seems to agree)
% lat_data = randn( [ size( mask ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 1 );
% LKChat.hatL
% 
% % do not mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 0 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 0 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 0 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (seems to agree)
% lat_data = randn( [ size( mask ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 0 );
% LKChat.hatL
% 
% %% %% D = 3
% %% % Rectangular mask and Kernel
% % Set Kernel to be isotropic Gaussian with FHWM
% Kernel = SepKernel( 3, 2 );
% 
% % Create a mask
% mask = ones( [ 10 10 10 ] );
% mask = pad_vals( mask, Kernel.truncation );
% 
% %% Stability for increasing resadd
% % mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 1 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 1 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 1 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (seems to agree)
% lat_data = randn( [ size( mask ) 10 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 1 );
% LKChat.hatL
% 
% % do not mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 0 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 0 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 0 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (seems to agree)
% lat_data = randn( [ size( mask ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 0 );
% LKChat.hatL
% %% % Circular mask and Kernel
% % Set Kernel to be isotropic Gaussian with FHWM
% Kernel = SepKernel( 3, 2 );
% % Create a mask and show it
% siz = 3;
% dx  = 0.5;
% [x,y,z] = meshgrid( -siz:dx:siz, -siz:dx:siz, -siz:dx:siz );
% xvals = [x(:), y(:), z(:)]';
% h     = reshape( GkerMV( xvals, 5 ), size(x) );
% mask  = logical( h > 0.003 );
% imagesc( mask(:,:,7) )
% clear h
% 
% %% Stability for increasing resadd
% % mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 1 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 1 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 1 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (maybe L2 needs a small fix)
% lat_data = randn( [ size( mask ) 10 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 1 );
% LKChat.hatL
% 
% % do not mask the lattice data
% LKC1 = LKC_wncfield_theory( mask, Kernel, 1, 0 );
% LKC3 = LKC_wncfield_theory( mask, Kernel, 3, 0 );
% LKC5 = LKC_wncfield_theory( mask, Kernel, 5, 0 );
% [ LKC1.L; LKC3.L; LKC5.L ]
% 
% % Show that LKC_conv_est provides similar result (maybe L2 needs a small fix)
% lat_data = randn( [ size( mask ) 200 ] );
% LKChat = LKC_conv_est( lat_data, mask, Kernel, 1, 0 );
% LKChat.hatL
%--------------------------------------------------------------------------
% AUTHOR: Fabian Telschow
%--------------------------------------------------------------------------

%% check mandatory input and get important constants
%--------------------------------------------------------------------------

% Get size of the mask
sM = size( mask );
% make mask logical
mask = logical( mask );

% Dimension of the domain, since matlab is not consistent for D<1, we need
% to catch this case 
if sM( 2 ) == 1 && length( sM ) == 2
    D = 1;
else
    D = length( sM );
end

% Check that method is implemented for dimension D
if D > 3
    error( strcat( 'D must be < 4. Higher dimensional domains have',...
                   'not been implemented' ) );
end

% If Kernel is numeric use an isotropic Gaussian Kernel else use the
% provided Kernel object
if isnumeric( Kernel )
    % Change numerical Kernel input to an object of class SepKernel
    Kernel = SepKernel( D, Kernel );

elseif ~isa( Kernel, 'SepKernel' )
    error( strcat( "The 'Kernel' must be either a numeric or an ",...
                   "object of class SepKernel!" ) );
end

%% Add/check optional input
%--------------------------------------------------------------------------

if ~exist( 'resadd', 'var' )
   % Default number of resolution increasing voxels between observed voxels
   resadd = 1;
end

if ~exist( 'enlarge', 'var' )
   % Default method for enlarge variable
   enlarge = ceil( resadd / 2 );
end

if ~exist( 'mask_lat', 'var' )
   % Default method for mask_lat controlling whether the input lat_data is
   % masked prior to convolving with the kernel.
   mask_lat = 1;
end

%% Main function
%--------------------------------------------------------------------------

% Allocate vector for Lipschitz Killing curvature
L = NaN * ones( [ 1 D ] );

% Get dx from resadd
dx = 1 / ( resadd + 1 );

% Get mask on higher resolution and the weights of each voxel for the
% volume computation.
if resadd ~= 0
    [ mask, weights ] = mask_highres( mask, resadd, enlarge );
    % Reduce weights matrix only to active voxels for speed up
    weights = weights( mask );
else
    weights = ones( [ sum( mask(:) ), 1 ] );
end

% Get the size of the resolution increased domain
Dimhr = size( mask );


%%%%%% BEGIN get the Riemannian metric/Lambda matrix assuming that the
%%%%%% voxels are independent Gaussian white noise
% Preallocate the Riemannian metric
g = zeros( [ Dimhr D D ] );

% Create index to fill the original mask at the correct voxels of the high
% resolution mask
index = cell( [ 1 D ] );
for d = 1:D
    index{d} = ( enlarge + 1 ):( resadd + 1 ):( Dimhr(d) - enlarge );
end

% Fill the resolution increased mask with the values from the original mask
% at the correct locations
onesField = zeros( Dimhr );
onesField( index{:} ) = 1;

% Mask the field, if opted for
if mask_lat
    onesField = mask .* onesField;
end

%%% Get the entries of the Riemannian metric
switch D
    case 1
        % Get the theoretical variance of the field and the variance of
        % derivatives
        VY    = fconv( onesField, @(x) Kernel.kernel{1}(x).^2, D,...
                        Kernel.truncation, dx );
        VdxY  = fconv( onesField, @(x) Kernel.dkernel{1}(x).^2, D,...
                        Kernel.truncation, dx );
        CYdxY = fconv( onesField, @(x) Kernel.kernel{1}(x) .* ...
                                        Kernel.dkernel{1}(x), D,...
                        min( Kernel.truncation,  Kernel.dtruncation ), dx );
        
        % Get the volume form
        g = ( VdxY .* VY - CYdxY.^2 ) ./ VY.^2;
        
    case 2
        % Get the partial derivatives of the Kernel
        grad_Kernel = Gradient( Kernel );
        dxKernel = grad_Kernel{1};
        dyKernel = grad_Kernel{2};
        clear grad_Kernel
        
        % Get the theoretical variance of the field and the variance of
        % derivatives
        VY      = fconv( onesField,...
                          { @(x) Kernel.kernel{1}(x).^2,...
                            @(x) Kernel.kernel{2}(x).^2 }, D,...
                          Kernel.truncation, dx );
        VdxY    = fconv( onesField,...
                          { @(x) dxKernel.kernel{1}(x).^2,...
                            @(x) dxKernel.kernel{2}(x).^2 }, D,...
                          Kernel.truncation, dx );
        VdyY    = fconv( onesField,...
                          { @(x) dyKernel.kernel{1}(x).^2,...
                            @(x) dyKernel.kernel{2}(x).^2 }, D,...
                          Kernel.truncation, dx );
        CYdyY   = fconv( onesField,...
                          { @(x) Kernel.kernel{1}(x) .* dyKernel.kernel{1}(x),...
                            @(x) Kernel.kernel{2}(x) .* dyKernel.kernel{2}(x) },...
                            D, Kernel.truncation, dx );
        CYdxY   = fconv( onesField,...
                          { @(x) Kernel.kernel{1}(x) .* dxKernel.kernel{1}(x),...
                            @(x) Kernel.kernel{2}(x) .* dxKernel.kernel{2}(x) },...
                            D, Kernel.truncation, dx );
        CdxYdyY = fconv( onesField,...
                          { @(x) dxKernel.kernel{1}(x) .* dyKernel.dkernel{1}(x),...
                            @(x) dxKernel.kernel{2}(x) .* dyKernel.dkernel{2}(x) },...
                            D, Kernel.truncation, dx );

        % Entries of riemanian metric
        g( :, :, 1, 1 ) = -CYdxY.^2 ./ VY.^2 + VdxY ./ VY;
        g( :, :, 2, 2 ) = -CYdyY.^2 ./ VY.^2 + VdyY ./ VY;
        g( :, :, 1, 2 ) = -CYdyY .* CYdxY ./ VY.^2 + CdxYdyY ./ VY;

     case 3
        % Get the partial derivatives of the Kernel
        grad_Kernel = Gradient( Kernel );
        dxKernel = grad_Kernel{1};
        dyKernel = grad_Kernel{2};
        dzKernel = grad_Kernel{3};
        clear grad_Kernel
        
        % Get the estimates of the covariances        
        VY   = fconv( onesField,...
                       { @(x) Kernel.kernel{1}(x).^2,...
                         @(x) Kernel.kernel{2}(x).^2,...
                         @(x) Kernel.kernel{3}(x).^2 }, D,...
                       Kernel.truncation, dx );
        VdxY = fconv( onesField,...
                       { @(x) dxKernel.kernel{1}(x).^2,...
                         @(x) dxKernel.kernel{2}(x).^2,...
                         @(x) dxKernel.kernel{3}(x).^2 }, D,...
                       Kernel.truncation, dx );
        VdyY = fconv( onesField,...
                       { @(x) dyKernel.kernel{1}(x).^2,...
                         @(x) dyKernel.kernel{2}(x).^2,...
                         @(x) dyKernel.kernel{3}(x).^2 }, D,...
                       Kernel.truncation, dx );
        VdzY = fconv( onesField,...
                       { @(x) dzKernel.kernel{1}(x).^2,...
                         @(x) dzKernel.kernel{2}(x).^2,...
                         @(x) dzKernel.kernel{3}(x).^2 }, D,...
                       Kernel.truncation, dx );
        
        CdxYdyY = fconv( onesField,...
                          { @(x) dxKernel.kernel{1}(x) .* dyKernel.kernel{1}(x),...
                            @(x) dxKernel.kernel{2}(x) .* dyKernel.kernel{2}(x),...
                            @(x) dxKernel.kernel{3}(x) .* dyKernel.kernel{3}(x) },...
                            D, Kernel.truncation, dx );

        CdxYdzY = fconv( onesField,...
                          { @(x) dxKernel.kernel{1}(x) .* dzKernel.kernel{1}(x),...
                            @(x) dxKernel.kernel{2}(x) .* dzKernel.kernel{2}(x),...
                            @(x) dxKernel.kernel{3}(x) .* dzKernel.kernel{3}(x) },...
                            D, Kernel.truncation, dx );
        CdyYdzY = fconv( onesField,...
                          { @(x) dzKernel.kernel{1}(x) .* dyKernel.kernel{1}(x),...
                            @(x) dzKernel.kernel{2}(x) .* dyKernel.kernel{2}(x),...
                            @(x) dzKernel.kernel{3}(x) .* dyKernel.kernel{3}(x) },...
                            D, Kernel.truncation, dx );
                        
        CYdxY = fconv( onesField,...
                        { @(x) dxKernel.kernel{1}(x) .* Kernel.kernel{1}(x),...
                          @(x) dxKernel.kernel{2}(x) .* Kernel.kernel{2}(x),...
                          @(x) dxKernel.kernel{3}(x) .* Kernel.kernel{3}(x) },...
                          D, Kernel.truncation, dx );
        CYdyY = fconv( onesField,...
                        { @(x) dyKernel.kernel{1}(x) .* Kernel.kernel{1}(x),...
                          @(x) dyKernel.kernel{2}(x) .* Kernel.kernel{2}(x),...
                          @(x) dyKernel.kernel{3}(x) .* Kernel.kernel{3}(x) },...
                          D, Kernel.truncation, dx );
        CYdzY = fconv( onesField,...
                        { @(x) dzKernel.kernel{1}(x) .* Kernel.kernel{1}(x),...
                          @(x) dzKernel.kernel{2}(x) .* Kernel.kernel{2}(x),...
                          @(x) dzKernel.kernel{3}(x) .* Kernel.kernel{3}(x) },...
                          D, Kernel.truncation, dx );
                 
        % Entries of riemanian metric/ Lambda matrix from neuroimaging
        g( :, :, :, 1, 1 ) = ( -CYdxY.^2 + VdxY .* VY ) ./ VY.^2;
        g( :, :, :, 2, 2 ) = ( -CYdyY.^2 + VdyY .* VY ) ./ VY.^2;
        g( :, :, :, 3, 3 ) = ( -CYdzY.^2 + VdzY .* VY ) ./ VY.^2;
        g( :, :, :, 1, 2 ) = ( -CYdyY .* CYdxY + CdxYdyY .* VY ) ./ VY.^2;
        g( :, :, :, 1, 3 ) = ( -CYdzY .* CYdxY + CdxYdzY .* VY ) ./ VY.^2;
        g( :, :, :, 2, 3 ) = ( -CYdzY .* CYdyY + CdyYdzY .* VY ) ./ VY.^2;
        
end

% Change nan to zero because there is a division by zero if masking
g = nan2zero( g );

% Setting up the default xvals_vecs
xvals  = cell( 1, D );

for d = 1:D
    xvals{d} = ( ( 1 - enlarge*dx ):dx:( sM(d) + enlarge*dx ) )...
        + Kernel.adjust(d);
end


%%%%%% BEGIN estimate the LKCs in different dimensions
%%% Compute 0th LKC
L0 = EulerChar( mask, 0.5, D );

%%% Compute LKCs for 0 < d < D
switch D
    case 1
        %%% Calculate LKC1        
        % Voxel size
        xvec = xvals{1};
        
        % Get the volume form
        vol_form = sqrt( max( g(:,1), 0 ) );
        
        % Restrict vol_form and dx to mask
        xvec     = xvec( mask );
        vol_form = vol_form( mask );     

        % Estimate of L1 by integrating volume form over the domain using
        % the trapezoid rule
        L(1) = diff( xvec ) * ( vol_form(1:end-1) + vol_form(2:end) ) / 2;
        
        %%% Fill the output structure
        geom.vol_form    = vol_form;
        geom.riem_metric = g;
        
    case 2
        % Get the voxel grid dimensions after resolution increase
        dx = diff( xvals{1} );
        dx = dx(1);
        dy = diff( xvals{2} );
        dy = dy(1);
        
        % Short cuts for the metric entries
        g_xx = g(:, :, 1, 1 );
        g_yy = g(:, :, 2, 2 );
        g_xy = g(:, :, 1, 2 );
        
        % Save g to the output structure and clear
        geom.riem_metric = g;
        clear g
        
        %%% Calculate LKC 2
        % Get the volume form, max introduced for stability, since at the
        % boundaries there might be tiny negative numbers due to numerical
        % calculations
        vol_form = sqrt( max( g_xx .* g_yy - g_xy.^2, 0 ) );
        
        % Restrict vol_form to mask
        vol_form = vol_form( mask );
        
        % Integate volume form over the domain. It assumes that each voxel
        % has the same volume dx*dy and simple midpoint integration is used
        % note that we also use weights to give an appropriate quotient to
        % boundary voxels, if resadd > 0, which takes into account that the
        % volume of the boundary voxels needs to be halved, or quartered, etc
        L(2) = sum( vol_form(:) .* weights(:) ) * dx * dy;
            
        %%% Calculate LKC 1
        % Find x and y shift boundary voxels, i.e. horizontal boundary
        % and vertical parts.
        [ bdry, weights] = bndry_voxels( mask, [ "x", "y" ] );
        
        % Integrate using trapozoid rule.
        % Note that we later need to remove half of the end points value,
        % of each line segment which are contained in the x and the y shift
        % boundary. They will be count double otherwise.
        L(1)  = 0.5 *...
                ( sum( sqrt( g_xx( bdry.x ) ) .* weights.x( bdry.x ) ) * dx...
                + sum( sqrt( g_yy( bdry.y ) .* weights.y( bdry.y ) ) ) * dy );
                               
        %%% Fill the output structure
        geom.vol_form = vol_form;
        
    case 3
        % Get the voxel grid dimensions after resolution increase
        dx = diff( xvals{1} );
        dx = dx(1);
        dy = diff( xvals{2} );
        dy = dy(1);
        dz = diff( xvals{3} );
        dz = dz(1);
        
        % Short cuts for the metric entries
        g_xx = g(:, :, :, 1, 1 );
        g_yy = g(:, :, :, 2, 2 );
        g_zz = g(:, :, :, 3, 3 );
        g_xy = g(:, :, :, 1, 2 );
        g_xz = g(:, :, :, 1, 3 );
        g_yz = g(:, :, :, 2, 3 );
        
        % Save g to the output structure and clear
        geom.riem_metric = g;
        clear g
        
        %%% Calculate LKC 3
        % Get the volume form, i.e. sqrt(det g), max introduced for
        % stability
        vol_form = sqrt( max(   g_xx.*g_yy.*g_zz...
                              + g_xy.*g_yz.*g_xz...
                              + g_xz.*g_xy.*g_yz...
                              - g_xz.^2.*g_yy...
                              - g_xy.^2.*g_zz...
                              - g_xx.*g_yz.^2, 0 ) );

        % Restrict vol_form to mask
        vol_form = vol_form( mask );
        
        % Integate volume form over the domain assuming each voxel having
        % the same volume dxdydz. Simple midpoint integration is used.
        L(3) = vol_form(:)' * weights(:) * dx * dy * dz;                  

        %%%%%% Calculate LKC2 and LKC1
        % Find faces and edges and their integration weights.
        [ bdry, weights ] = bndry_voxels( mask );
        
        %%% Calculate LKC 2;
        % Integrate volume form of faces to get LKC2
        weights.xy = weights.xy( weights.xy ~= 0 );        
        L(2) = sum( sqrt( max( g_xx( bdry.xy ) .* g_yy( bdry.xy )...
                              - g_xy( bdry.xy ).^2, 0 ) )...
                              .* weights.xy(:) ) * dx * dy / 2;
                          
        weights.xz = weights.xz( weights.xz ~= 0 );
        L(2) = L(2) + sum( sqrt( max( g_xx( bdry.xz ) .* g_zz( bdry.xz )...
                              - g_xz( bdry.xz ).^2, 0 ) )...
                              .* weights.xz(:) ) * dx * dz / 2;

        weights.yz = weights.yz( weights.yz ~= 0 );
        L(2) = L(2) + sum( sqrt( max( g_yy( bdry.yz ) .* g_zz( bdry.yz )...
                              - g_yz( bdry.yz ).^2, 0 ) )...
                              .* weights.yz(:) ) * dy * dz / 2;
        
        %%% Calculate LKC 1
        % Integrate volume form of edges to get LKC2
        weights.x = weights.x( weights.x ~= 0 );        
        L(1) = sum( sqrt( max( g_xx( bdry.x ), 0 ) )...
                              .* weights.x(:) ) * dx;
                          
        weights.z = weights.z( weights.z ~= 0 );
        L(1) = L(1) + sum( sqrt( max( g_zz( bdry.z ), 0 ) )...
                              .* weights.z(:) ) * dz;

        weights.y = weights.y( weights.y ~= 0 );
        L(1) = L(1) + sum( sqrt( max( g_yy( bdry.y ), 0 ) )...
                              .* weights.y(:) ) * dy;
end
%%%%%% END estimate the LKCs in different dimensions

%% Prepare output structure
%--------------------------------------------------------------------------
% Summarize output
LKC  = struct( 'L', L, 'L0', L0, 'geomQuants',...
               geom );

return