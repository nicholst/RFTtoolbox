function [ Lambda_est, xvals ] = Lambda_conv_est( lat_data, Kernel, resAdd,...
                                                  enlarge )
% LAMBDA_CONV_EST( lat_data, Kernel, resAdd, enlarge ) calculates an
% estimate of the induced Riemannian metric from a convolution field. It is
% known as the Lambda matrix in neuroimaging.
% This function uses the exact formula from taking the derivatives of the
% kernels and computing the corresponding convolutions.
%
%--------------------------------------------------------------------------
% ARGUMENTS
% Mandatory
%  lat_data  data array T_1 x ... x T_D x N. Last index enumerates the
%            samples. Note that N > 1 is required!
%  Kernel    either a structure or a numeric.
%            If structure it should contain the following fields:
%            - kernel: function handle computing the kernel
%              Optional if the field 'kernel' is numeric the convolution
%              field is assumed to be derived from a Gaussian kernel and 
%              the field 'dkernel' and 'truncation' is added automatically.
%            - dkernel: D by 1 cell array containing the function handles
%                       for the kernels of the derivative
%                       in each direction.
%            - truncation:
%              a window around the points at which to evaluate the kernel
%              setting this parameter allows for quicker computation of the
%              convolution field and has very little effect on the values of
%              the field for kernels that have light tails such as the 
%              Gaussian kernel.
%            The following fields are OPTIONAL:
%            - adjust_kernel:
%               a D by 1 vector that allows you to compute the convolution
%               field at an offset. This is useful for computing 
%               derivatives numerically. Default is not to use this feature.
%
%            If Kernel is numeric, the convolution field is generated by 
%            smoothing with an isotropic Gaussian kernel with FWHM = Kernel.
%            Truncation and adjust_kernel are set to be default values.
% Optional
%  resAdd    the amount of voxels added equidistantly inbetween the
%            existing voxels. Default is 1.
%  enlarge   a numeric which must be a positive integer or zero. The
%            convolution field is computed on a domain enlarged in each
%            direction by 'enlarge' voxels. Note if resAdd ~=0 the added
%            voxels are in high resolution. Default 0. 
%--------------------------------------------------------------------------
% OUTPUT
%   Lambda_est  an array of size hrT_1 x ... x hrT_D x D x D. Containing
%               the D x D Lambda matrix/Riemannian metric at each voxel
%               from the chosen increased resolution defined by resAdd.
%   xvals       the grid values of the high resolution grid.
% -------------------------------------------------------------------------
% DEVELOPER TODOs:
%--------------------------------------------------------------------------
% EXAMPLES
% %1D
% rf   = noisegen( [35 35], 50, 6 );
% mask = ones([35 35);
% L = LKCestim_GaussConv( rf, 3, mask, 1 );
%
% %2D
% rf   = noisegen( [35 35], 50, 6 );
% mask = ones([35 35);
% L = LKCestim_GaussConv( rf, 3, mask, 1 );
% 
% %3D
%--------------------------------------------------------------------------
% AUTHOR: Fabian Telschow
%--------------------------------------------------------------------------


%% ------------------------------------------------------------------------
% check mandatory input and get important constants
%--------------------------------------------------------------------------
% size of the domain
s_lat_data = size( lat_data );

% dimension of the domain
D = length( s_lat_data( 1:end-1 ) );

% get number of subjects/samples
nsubj = s_lat_data( D + 1 );

% get variable domain counter
index  = repmat( {':'}, 1, D );

% check that method is implemented for dimension D
if D > 3
    error( 'D must be < 4. Higher dimensional domains have not been implemented')
end


%% ------------------------------------------------------------------------
%  add/check optional values
%--------------------------------------------------------------------------
if ~exist( 'resAdd', 'var' )
   % default number of resolution increasing voxels between observed voxels
   resAdd = 1;
end

if ~exist( 'enlarge', 'var' )
   % default number of resolution increasing voxels between observed voxels
   enlarge =  ceil( resAdd / 2 );
end


%% ------------------------------------------------------------------------
%  main function
%--------------------------------------------------------------------------
%%% get the convolution fields and their derivatives
if isnumeric( Kernel )
    % get the convolution fields and their derivatives
    [ convY, xvals ] = convfield_struct( lat_data, Kernel, resAdd, D, 0,...
                                         enlarge );
    DconvY = convfield_struct( lat_data, Kernel, resAdd, D, 1, enlarge );
elseif isstruct( Kernel )
    if ~isfield( Kernel, 'kernel' )
        error( strcat( "The structure 'Kernel' needs to have a",...
                       "field 'kernel'.\n%s" ),...
               "Please refer to the input instructions." )
    elseif isnumeric( Kernel.kernel )
        % get the convolution fields and their derivatives
        [ convY, xvals ] = convfield_struct( lat_data, Kernel, resAdd,...
                                             D, 0, enlarge );
        DconvY = convfield_struct( lat_data, Kernel, resAdd, D, 1, enlarge );
    else
        % set default for the field 'adjust_kernel' if it is missing 
        if ~isfield( Kernel, 'adjust_kernel' )
            Kernel.adjust_kernel = zeros( D, 1 );            
        end
        
        % check whether the mandatory truncation field exists
        if ~isfield( Kernel, 'truncation' )
            error( strcat( "For a general Kernel you need to",...
                           " provide a field 'truncation'!\n%s" ),...
                           "Please read the input instructions!" )
        end
        
        % check whether the kernel field has enough kernels
        if length( Kernel.dkernel ) == D
            error( strcat( "You need to provide the dkernel for each",...
                           " dimension.\n%s" ),...
                           "Please read the input instructions!" )
        end
        
        % define Kernel structures for the derivative
        dKernel = Kernel;
        dKernel.kernel = Kernel.dkernel;
        
        % get the convolution fields and their derivatives
        [ convY, xvals ] = convfield_struct( lat_data, Kernel, resAdd,...
                                             D, 0, enlarge );
        DconvY = convfield_struct( lat_data, dKernel, resAdd,...
                                             D, 1, enlarge );
        
    end
else
    error( "The 'Kernel' must be either a numeric or a kernel structure!" )
end

% get size of the resolution increased domain
sY = size( convY );

% allocate output the entries of the Riemannian metric
Lambda_est = zeros( [ sY(1:end-1) D D ] );

%%%%%% BEGIN compute the Riemannian metric
switch D
    case 1
        % get the estimates of the variances and covariances required to
        % compute the Riemannian metric/Lambda matrix
        VY    = var( convY,  0, D+1 );
        VdxY  = var( DconvY, 0, D+1 );
        CYdxY = sum( ( DconvY - mean( DconvY, D+1 ) ) .* convY, D+1 ) ...
                                                            / ( nsubj - 1 );
        
        % get the Riemannian metric at each point
        Lambda_est( index{:}, 1 ) = ( VdxY .* VY - CYdxY.^2 ) ./ VY.^2;
    case 2
        % rename the partial derivatives of the convolution field
        convYx = squeeze( DconvY( index{:}, :, 1 ) );
        convYy = squeeze( DconvY( index{:}, :, 2 ) );
        clear DconvY
        
        % get the estimates of the variances and covariances required to
        % compute the Riemannian metric/Lambda matrix
        VY   = var( convY,  0, D+1 ); 
        VdxY = var( convYx, 0, D+1 );
        VdyY = var( convYy, 0, D+1 );
        CdxYdyY = sum( ( convYy - mean( convYy, D+1 ) ) .* ...
                         convYx, D+1 ) / ( nsubj - 1 );
        CYdxY = sum( ( convYx - mean( convYx, D+1 ) ) .* ...
                       convY, D+1 ) / ( nsubj - 1 );
        CYdyY = sum( ( convYy - mean( convYy, D+1 ) ) .* ...
                       convY, D+1 ) / ( nsubj - 1 );
                 
        % entries of Riemanian metric
        g_xx = -CYdxY.^2 ./ VY.^2 + VdxY ./ VY;
        g_yy = -CYdyY.^2 ./ VY.^2 + VdyY ./ VY;
        g_xy = -CYdyY .* CYdxY ./ VY.^2 + CdxYdyY ./ VY;
        
        % prepare output
        Lambda_est( index{:}, 1, 1 ) = g_xx;
        Lambda_est( index{:}, 1, 2 ) = g_xy;
        Lambda_est( index{:}, 2, 1 ) = g_xy;
        Lambda_est( index{:}, 2, 2 ) = g_yy;
    case 3
        % rename the partial derivatives of the convolution field
        convYx = squeeze( DconvY( index{:}, :, 1 ) );
        convYy = squeeze( DconvY( index{:}, :, 2 ) );
        convYz = squeeze( DconvY( index{:}, :, 3 ) );
        clear DconvY
        
        % get the estimates of the covariances
        VY   = var( convY,  0, D+1 );
        VdxY = var( convYx, 0, D+1 );
        VdyY = var( convYy, 0, D+1 );
        VdzY = var( convYy, 0, D+1 );
        
        CdxYdyY = sum( ( convYy - mean( convYy, D+1 ) ) .* ...
                       ( convYx - mean( convYx, D+1 ) ), D+1 ) / (nsubj-1);
        CdxYdzY = sum( ( convYx - mean( convYx, D+1 ) ) .* ...
                       ( convYz - mean( convYz, D+1 ) ), D+1 ) / (nsubj-1);
        CdyYdzY = sum( ( convYy - mean( convYy, D+1 ) ) .* ...
                       ( convYz - mean( convYz, D+1 ) ), D+1 ) / (nsubj-1);

        CYdxY = sum( ( convYx - mean( convYx, D+1 ) ) .* ...
                     ( convY  - mean( convY,  D+1 ) ), D+1 ) / (nsubj-1);
        CYdyY = sum( ( convYy - mean( convYy, D+1 ) ) .* ...
                     ( convY  - mean( convY,  D+1 ) ), D+1 ) / (nsubj-1);
        CYdzY = sum( ( convYz - mean( convYz, D+1 ) ) .* ...
                     ( convY  - mean( convY,  D+1 ) ), D+1 ) / (nsubj-1);
                 
        % entries of riemanian metric/ Lambda matrix from neuroimaging
        g_xx = ( -CYdxY.^2 + VdxY .* VY ) ./ VY.^2;
        g_yy = ( -CYdyY.^2 + VdyY .* VY ) ./ VY.^2;
        g_zz = ( -CYdzY.^2 + VdzY .* VY ) ./ VY.^2;
        g_xy = ( -CYdyY .* CYdxY + CdxYdyY .* VY ) ./ VY.^2;
        g_xz = ( -CYdzY .* CYdxY + CdxYdzY .* VY ) ./ VY.^2;
        g_yz = ( -CYdzY .* CYdyY + CdyYdzY .* VY ) ./ VY.^2;
        
        % prepare output
        Lambda_est( index{:}, 1, 1 ) = g_xx;
        Lambda_est( index{:}, 1, 2 ) = g_xy;
        Lambda_est( index{:}, 1, 3 ) = g_xz;
        Lambda_est( index{:}, 2, 1 ) = g_xy;
        Lambda_est( index{:}, 2, 2 ) = g_yy;
        Lambda_est( index{:}, 2, 3 ) = g_yz;
        Lambda_est( index{:}, 3, 1 ) = g_xz;
        Lambda_est( index{:}, 3, 2 ) = g_yz;
        Lambda_est( index{:}, 3, 3 ) = g_zz;
end
%%%%%% END compute the Riemannian metric

% remove NaNs and replace with zero
Lambda_est = nan2zero( Lambda_est );

return