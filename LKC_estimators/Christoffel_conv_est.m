function [ Lambda_est, xvals ] = Christoffel_conv_est( lat_data, Kernel, resadd,...
                                                  enlarge )
% Christoffel_num_est( lat_data, Kernel, resadd, h, enlarge ) calculates an
% estimate of the induced Riemannian metric from a convolution field. It is
% known as the Lambda matrix in neuroimaging.
% This function uses the exact formula from taking the derivatives of the
% kernels and computing the corresponding convolutions.
%
%--------------------------------------------------------------------------
% ARGUMENTS
% Mandatory
%  lat_data  data array T_1 x ... x T_D x N. Last index enumerates the
%            samples. Note that N > 1 is required!
%  Kernel    either an object of class SepKernel or a numeric.
%            If class SepKernel all fields for first and second derivatives
%            must be specified.
%
%            If Kernel is numeric, the convolution field is generated by 
%            smoothing with an isotropic Gaussian kernel with FWHM = Kernel.
%            Truncation and adjust_kernel are set to be default values.
% Optional
%  resadd    the amount of voxels added equidistantly inbetween the
%            existing voxels. Default is 1.
% h          a numeric used to calculate the derivatives i.e. via
%            X(v+h)-X(v))/h. Default is 0.00001. Avoid taking h to be
%            too small for numerical precision reasons
%  enlarge   a numeric which must be a positive integer or zero. The
%            convolution field is computed on a domain enlarged in each
%            direction by 'enlarge' voxels. Note if resadd ~=0 the added
%            voxels are in high resolution. Default 0. 
%--------------------------------------------------------------------------
% OUTPUT
%   Lambda_est  an array of size hrT_1 x ... x hrT_D x D x D. Containing
%               the D x D Lambda matrix/Riemannian metric at each voxel
%               from the chosen increased resolution defined by resadd.
%   xvals       the grid values of the high resolution grid.
% -------------------------------------------------------------------------
% DEVELOPER TODOs:
%--------------------------------------------------------------------------
% EXAMPLES
% %1D
% rf   = noisegen( [35 35], 50, 6 );
% mask = ones([35 35);
% L = LKCestim_GaussConv( rf, 3, mask, 1 );
%
% %2D
% rf   = noisegen( [35 35], 50, 6 );
% mask = ones([35 35);
% L = LKCestim_GaussConv( rf, 3, mask, 1 );
% 
% %3D
%--------------------------------------------------------------------------
% AUTHOR: Fabian Telschow
%--------------------------------------------------------------------------

%% Check mandatory input and get important constants
%--------------------------------------------------------------------------

% Size of the domain
s_lat_data = size( lat_data );

% Dimension of the domain
D = length( s_lat_data( 1:end-1 ) );

if D < 3
    error("Don't waste your time. You do not need them.")
end
if D > 3
    error("Not implemented for D>3.")
end

% Get number of subjects/samples
nsubj = s_lat_data( D + 1 );

% Get variable domain counter
index  = repmat( {':'}, 1, D );

% Check that method is implemented for dimension D
if D > 3
    error( 'D must be < 4. Higher dimensional domains have not been implemented')
end

%% Add/check optional values
%--------------------------------------------------------------------------

if ~exist( 'resadd', 'var' )
   % Default number of resolution increasing voxels between observed voxels
   resadd = 1;
end

if ~exist( 'enlarge', 'var' )
   % Default number of resolution increasing voxels between observed voxels
   enlarge =  ceil( resadd / 2 );
end

%% Main function
%--------------------------------------------------------------------------

% Get the convolution fields and their derivatives
if isa( Kernel, 'SepKernel' ) || isnumeric( Kernel )
    [ Y, xvals ] = convfield( lat_data, Kernel, resadd, D, 0,...
                                         enlarge );
    DconvY = convfield( lat_data, Kernel, resadd, D, 1, enlarge );
    D2convY = convfield( lat_data, Kernel, resadd, D, 2, enlarge );

else
    error( "The 'Kernel' must be either a numeric or a kernel structure!" )
end

% Get size of the resolution increased domain
sY = size( Y );

% Allocate output the entries of the Riemannian metric
Gamma_est = zeros( [ sY( 1:end-1 ) D D D ] );

%%%%%% BEGIN compute the Riemannian metric
switch D
    case 1
        
    case 2
        
    case 3
        % Rename the partial derivatives of the convolution field
        Yx = squeeze( DconvY( index{:}, :, 1 ) );
        Yy = squeeze( DconvY( index{:}, :, 2 ) );
        Yz = squeeze( DconvY( index{:}, :, 3 ) );
        
        Yxx = squeeze( D2convY( index{:}, :, 1, 1 ) );
        Yyy = squeeze( D2convY( index{:}, :, 2, 2 ) );
        Yzz = squeeze( D2convY( index{:}, :, 3, 3 ) );

        Yxy = squeeze( D2convY( index{:}, :, 1, 2 ) );
        Yxz = squeeze( D2convY( index{:}, :, 1, 3 ) );
        Yyz = squeeze( D2convY( index{:}, :, 2, 3 ) );
        
        clear DconvY D2convY
        
        % Get the estimates of the covariances
        VY   = var( Y,  0, D+1 );
        
        CdYY = NaN * ones( [ sY 3] );
        CdYY( index{:}, 1 ) = vectcov( Y, Yx, D+1, 1 );
        CdYY( index{:}, 2 ) = vectcov( Y, Yy, D+1, 1 );
        CdYY( index{:}, 3 ) = vectcov( Y, Yz, D+1, 1 );
        
        Cd2YY = NaN * ones( [ sY 3 3] );
        Cd2YY( index{:}, 1, 1 ) = vectcov( Y, Yxx, D+1, 1 );
        Cd2YY( index{:}, 1, 2 ) = vectcov( Y, Yxy, D+1, 1 );
        Cd2YY( index{:}, 1, 3 ) = vectcov( Y, Yxz, D+1, 1 );
        Cd2YY( index{:}, 2, 2 ) = vectcov( Y, Yyy, D+1, 1 );
        Cd2YY( index{:}, 2, 3 ) = vectcov( Y, Yyz, D+1, 1 );
        Cd2YY( index{:}, 3, 3 ) = vectcov( Y, Yzz, D+1, 1 );
        Cd2YY( index{:}, 3, 1 ) = Cd2YY( index{:}, 1, 3 );
        Cd2YY( index{:}, 3, 2 ) = Cd2YY( index{:}, 2, 3 );
        Cd2YY( index{:}, 2, 1 ) = Cd2YY( index{:}, 1, 2 );

        CdYdY = NaN * ones( [ sY 3 3] );
        CdYdY( index{:}, 1, 1 ) = var( Yx,  0, D+1 );
        CdYdY( index{:}, 2, 2 ) = var( Yy,  0, D+1 );
        CdYdY( index{:}, 3, 3 ) = var( Yz,  0, D+1 );
        CdYdY( index{:}, 1, 2 ) = vectcov( Yx, Yy, D+1, 1 );
        CdYdY( index{:}, 1, 3 ) = vectcov( Yx, Yz, D+1, 1 );
        CdYdY( index{:}, 2, 3 ) = vectcov( Yy, Yz, D+1, 1 );
        CdYdY( index{:}, 2, 1 ) = CdYdY( index{:}, 1, 2 );
        CdYdY( index{:}, 3, 1 ) = CdYdY( index{:}, 1, 3 );
        CdYdY( index{:}, 3, 2 ) = CdYdY( index{:}, 2, 3 );

        Cd2YdY = NaN * ones( [ sY 3 3 3] );
        Cd2YdY( index{:}, 1, 1, 1 ) = vectcov( Yxx, Yx, D+1, 1 );
        Cd2YdY( index{:}, 1, 1, 2 ) = vectcov( Yxx, Yy, D+1, 1 );
        Cd2YdY( index{:}, 1, 1, 3 ) = vectcov( Yxx, Yz, D+1, 1 );
        Cd2YdY( index{:}, 2, 2, 1 ) = vectcov( Yyy, Yx, D+1, 1 );
        Cd2YdY( index{:}, 2, 2, 2 ) = vectcov( Yyy, Yy, D+1, 1 );
        Cd2YdY( index{:}, 2, 2, 3 ) = vectcov( Yyy, Yz, D+1, 1 );
        Cd2YdY( index{:}, 3, 3, 1 ) = vectcov( Yzz, Yx, D+1, 1 );
        Cd2YdY( index{:}, 3, 3, 2 ) = vectcov( Yzz, Yy, D+1, 1 );
        Cd2YdY( index{:}, 3, 3, 3 ) = vectcov( Yzz, Yz, D+1, 1 );
        
        Cd2YdY( index{:}, 1, 2, 1 ) = vectcov( Yxy, Yx, D+1, 1 );
        Cd2YdY( index{:}, 1, 2, 2 ) = vectcov( Yxy, Yy, D+1, 1 );
        Cd2YdY( index{:}, 1, 2, 3 ) = vectcov( Yxy, Yz, D+1, 1 );
        Cd2YdY( index{:}, 2, 1, 1 ) = Cd2YdY( index{:}, 1, 2, 1 );
        Cd2YdY( index{:}, 2, 1, 2 ) = Cd2YdY( index{:}, 1, 2, 2 );
        Cd2YdY( index{:}, 2, 1, 3 ) = Cd2YdY( index{:}, 1, 2, 3 );
        
        Cd2YdY( index{:}, 1, 3, 1 ) = vectcov( Yxz, Yx, D+1, 1 );
        Cd2YdY( index{:}, 1, 3, 2 ) = vectcov( Yxz, Yy, D+1, 1 );
        Cd2YdY( index{:}, 1, 3, 3 ) = vectcov( Yxz, Yz, D+1, 1 );
        Cd2YdY( index{:}, 3, 1, 1 ) = Cd2YdY( index{:}, 1, 3, 1 );
        Cd2YdY( index{:}, 3, 1, 2 ) = Cd2YdY( index{:}, 1, 3, 2 );
        Cd2YdY( index{:}, 3, 1, 3 ) = Cd2YdY( index{:}, 1, 3, 3 );
        
        Cd2YdY( index{:}, 2, 3, 1 ) = vectcov( Yyz, Yx, D+1, 1 );
        Cd2YdY( index{:}, 2, 3, 2 ) = vectcov( Yyz, Yy, D+1, 2 );
        Cd2YdY( index{:}, 2, 3, 3 ) = vectcov( Yyz, Yz, D+1, 3 );
        Cd2YdY( index{:}, 3, 2, 1 ) = Cd2YdY( index{:}, 2, 3, 1 );
        Cd2YdY( index{:}, 3, 2, 2 ) = Cd2YdY( index{:}, 2, 3, 2 );
        Cd2YdY( index{:}, 3, 2, 3 ) = Cd2YdY( index{:}, 2, 3, 3 );

        % Entries of Christoffel symbol matrix
        for k = 1:D
            for d = k:D
                for dd = 1:D
                    Gamma_est( index{:}, k, d, dd ) = ...
                        Cd2YdY( index{:}, k, d, dd ) ./ VY - ...
                        CdYY( index{:}, k ) .*...
                                        CdYdY( index{:}, d, dd ) ./ VY.^2 - ...
                        Cd2YY( index{:}, k, d ) .*...
                                        CdYY( index{:}, dd ) ./ VY.^2 + ...
                        CdYY( index{:}, d ) .*...
                                        Cd2YY( index{:}, k, dd ) ./ VY.^2 + ...
                        2 * CdYY( index{:}, k ) .* CdYY( index{:}, d ) .*...
                                        CdYY( index{:}, dd ) ./  VY.^3;      
                end
            end
        end
        
end
%%%%%% END compute the Riemannian metric

% Remove NaNs and replace with zero
Lambda_est = nan2zero( Lambda_est );

return